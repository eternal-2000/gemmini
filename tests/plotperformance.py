"""
Plots performance in gigaflops (Gflops) per second against matrix dimensions, and compares with reference
implementation. For testing, matrices are square as a standard convenience.
"""

import matplotlib.pyplot as plt
from pathlib import Path
import subprocess, sys, os, argparse

def getPath(name: str, debug: bool = False) -> Path:
    """
    Gets path to executable. Assumes location of executable is in ../build.
    """
    root_dir = Path(__file__).parent.parent
    build_dir = root_dir / "build"
    executable = build_dir / name

    if debug:
        print(f"Looking for executable in {executable}", file = sys.stderr)

        if not build_dir.exists():
            print(f"Error: Build directory {build_dir} does not exist", file = sys.stderr)
            raise FileNotFoundError(f"Build directory not found: {build_dir}")

        if not executable.exists():
            print(f"Error: Executable {name} not found in {build_dir}",
                  file = sys.stderr)
            raise FileNotFoundError(f"Executable {name} not found in {build_dir}")

        if not executable.is_file():
            print(f"Error: Path exists but is not a file: {executable}", file = sys.stderr)
            raise FileNotFoundError(f"Not a file: {executable}")

        if not os.access(executable, os.X_OK):
            print(f"Error: File exists but is not executable: {executable}", file = sys.stderr)
            raise PermissionError(f"File not executable: {executable}")
    return executable    

def runMM(name: str, init_n: int, final_n: int, inc: int = 48, reps: int = 3,
          debug: bool = False) -> None:
    """
    Runs a dgemm matrix multiplication function "name" which sends its performance (in Gflops/sec) directly to
    stdout, and compares it with the BLIS reference implementation.
    Output will be lines of the form
    
    dimension (int)    performance (float)     reference_performance (float)

    Name can be one of: testGeMM - a homemade GeMM implementation
                        RGeMM - a homemade randomised GeMM (RGeMM) implementation    
    
    Test matrices are square, i.e. m = n = k, and dimensions stored in array sqdim[].
    Flop counts (in Gflops) are given in array gflops[].
    Plots of Gflop count per second generated by matplotlib.
    """

#   known_functions = ["RGeMM", "testgemm"]
#   assert(name in known_functions), "Error: Name must be a valid function." 
    
    try:
        executable = getPath(name)
    except FileNotFoundError as err:
        print(f"Fatal error: {err}", file = sys.stderr)
        raise

    if (name != "RGeMM"):
        command = [str(executable), str(init_n), str(final_n), str(inc), str(reps)]
    else:
        pass

    if debug:
        print(f"Attempting to execute {' '.join(command)}", file = sys.stderr)
    
    try:
        process = subprocess.run(
            command,
            stdout = subprocess.PIPE,
            text = True,
            check = True)

        output_data = process.stdout.splitlines()    
        sqdim = []
        gflops = []
        ref_gflops = []
        
        for line in output_data:
            n, perf, ref_perf = line.split()
            sqdim.append(int(n))
            gflops.append(float(perf))
            ref_gflops.append(float(ref_perf))

    except subprocess.CalledProcessError as err:
        print(f"Error calling {name} with parameters {init_n}, {final_n}, {inc}, {reps}: {err}",
              file = sys.stderr)
        raise

    except ValueError as err:
        print(f"Error parsing output of {name} with parameters {init_n, final_n, inc, reps}: {err}",
              file = sys.stderr)
        raise
        
    xAxis = "Matrix dimensions: m = n = k"
    yAxis = "Performance (Gflops/sec)"
    figtitle = "Performance against size of square matrices"
    size = (10,6)
    
    plt.figure(figsize=size)
    plt.plot(sqdim, gflops, marker = 'o', color = 'b', label = f"{name}")
    plt.plot(sqdim, ref_gflops, marker = 'x', color = 'r', label = "BLIS")
    plt.xlabel(xAxis)
    plt.ylabel(yAxis)
    plt.title(figtitle)
    plt.grid(True)
    plt.legend()
    plt.show()

if __name__ == "__main__":
    try:
        runMM("driver", 48, 1600)
    except Exception as err:
        print(f"Fatal error: {err}", file = sys.stderr)
        sys.exit(1)
